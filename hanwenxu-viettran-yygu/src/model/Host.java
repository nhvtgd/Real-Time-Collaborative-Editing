package model;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.NoSuchElementException;

import server_client.CollabClient;
import server_client.CollabServer;
import ui.ErrorDialog;
import document.OperationEngineException;


// Refer to README on how to run this

/* 
 * Thread safety: Each instance of the client or server that that is generated by the host
 * will be on a separate thread. Only a single thread will access this program at a time, so 
 * we will not have thread-safety issues in this class.
 * 
 * Testing strategy: see HostTest.java
 * 
 * Rep invariant: type, port, username are not null
 */

/**
 * The alternative, text-based method to creating server and clients. Simply click run
 * and then type in commands as described.
 * 
 * The Host class would be run to start the document editor. It takes in user inputs that 
 * would determine whether or not to launch a server or a client. It would then 
 * start the appropriate GUI from the IP address and port number that is provided.
 *
 */
public class Host {
    
    /** The userName supply by the user */
	private String username;
    /** The IP address to connect to */
    private String ip;
    /** Port number */
    public final int port;
    /** Server or client */
    private final String type;
    
    /** default IP */
    private final static String DEFAULT_IP = "localhost";
    /** default port */
    private final static int DEFAULT_PORT = 4444;
    /** default username */
    private final static String DEFAULT_USERNAME = "Anonymous";
    
    /** static host variable */
    static Host host;
    
    /**
     * Constructor for the Host class. Simply initializes all instance variables.
     * @param type - whether it is a server or client
     * @param IP - the ip address
     * @param port - the port number
     * @param username - the username
     */  
    public Host(String type, String IP, int port, String username) {
        this.type = type;
        this.port = port;
        this.ip = IP;
		this.username = username;
	}

    
    /**
     * Calls the corresponding constructor based on whether or not the user wants to 
     * start up a server or client. Passes all the implementation to the Collab class
     * by calling either CollabServer's serve() method or CollabClient's connect() method.
     * @throws OperationEngineException if the operation finds an incosistency
     */
    public void start() {
        
        if (type.toLowerCase().equals("server")) {
            try {             
                CollabServer userServer = new CollabServer(ip, port, username);
                userServer.serve();
            } catch (IOException e) {
                new ErrorDialog(e.toString());              
            }
        }
        if (type.toLowerCase().equals("client")) {
            try {
                CollabClient userClient = new CollabClient(ip, port, username);
                userClient.connect();
            } catch (IOException e) {
                new ErrorDialog(e.toString());
            }
        }
        else {
            throw new RuntimeException("Error parsing server/client");
        }
    }
    
    /**
     * Parses commands from an input stream. If ran from main, the input stream would be System.in.
     * A ByteArrayInputStream is passed in for testing purposes
     * It then creates the appropriate fields to call the constructor.
     * A new thread is dedicated for each command.
     * 
     * @param in - the InputStreamReader to retrieve commands from
     * @param test - whether or not this is ran by a JUnit test. If it is a test, then
     * don't start the GUI.
     * @return a static instance of Host that is used by the test      
     * @throws IOException if the inputstream is corrupted
     */
    public static Host parseInputs(InputStreamReader in, Boolean test) throws IOException {
        BufferedReader br = new BufferedReader(in);
        String[] args = null;
        while (true) {
            try {
                String input = br.readLine();
                args = input.split(" ");
            }
            catch (NoSuchElementException e) {
                System.exit(0);
            }

            try {
                int portNo;
                if (args.length > 4) {
                    throw new IllegalArgumentException("Too many arguments");
                }
                if (!args[0].toLowerCase().equals("client") && !args[0].toLowerCase().equals("server")) {
                    throw new IllegalArgumentException("first argument must be 'server' or 'client'");
                }
                
                
                if (args.length == 1) {
                    host = new Host(args[0], DEFAULT_IP, DEFAULT_PORT, DEFAULT_USERNAME);
                    
                }
                else if (args.length == 2) {
                    host = new Host(args[0], DEFAULT_IP, DEFAULT_PORT, args[1]);
                }
                else if (args.length == 3) {
                    
                    try {
                        portNo = Integer.parseInt(args[2]);
                        
                    }
                    catch (NumberFormatException e) {
                        throw new IllegalArgumentException("You must enter a number under port");
                    }
                    host = new Host(args[0], args[1], portNo, DEFAULT_USERNAME);                   
                    
                }
                else if (args.length == 4) {
                    try {
                        portNo = Integer.parseInt(args[3]);
                        
                    }
                    catch (NumberFormatException e) {
                        throw new IllegalArgumentException("You must enter a number under port");
                    }
                    host = new Host(args[0], args[2], portNo, args[1]);
                }
                if (test)
                    return host;
                Thread thread = new Thread(){
                    public void run(){
                        host.start();
                    }
                  };                  
                  thread.start();
                
            } catch (IllegalArgumentException e) {
                System.err.println("usage: (client | server) [Username] IP Port");              
            }
        
        }
        
    }
    
    /** @return "server" or "client". Used for testing */
    public String getType() {
        return this.type;
    }
    
    /** @return port number of the server or client. Used for testing */
    public int getPort() {
        return this.port;
    }
    
    /** @return username of the server or client. Used for testing */
    public String getUserName() {
        return this.username;
    }
    
    /** @return ip address of the server or client. Used for testing */
    public String getIP() {
        return this.ip;
    }
    
    /**
     * Main method. Asks for user command. Calls parseInputs to parse.
     * @param args the command that we want to parse
     * @throws IOException for input/output errors
     */
    public static void main(String[] args) throws IOException {
        System.out.println("Usage: \n(client | server)\n(client | server) username\n(client | server) IP port\n(client | server) username IP port");
        parseInputs(new InputStreamReader(System.in), false);      
    }

}
